# Introduction
It's an exciting milestone in an app's lifecycle: You've taken your app from idea to functional, and it's time to get it into the hands of beta testers. Life is great! 
Except… As you think of the manual legwork that'll be needed to get your app provisioned and submitted and all your testers on-boarded, your heart sinks just a bit.
# Lecture
## Manual Build Steps
Here's a quick review of the conventional steps needed at this point:
**[Slide 1]** 
To start, you'd need to register all your test devices on the Apple Developer Portal. We get a pass on this one, since we've already addressed device registration with `deliver`. Onwards!
**[Slide 2]** 
You'd then create an archive, remembering to manually bump your build number. Then you stand by and cross your fingers while Xcode validates your app and all your distribution certificates and assets. 
**[Slide 3]** 
Then it's on to Xcode's Organizer, where you'd choose either to distribute your app with Test Flight or a third party service. You'd also choose a development team and account, if your app is Universal, and select any on-demand resources to be uploaded, including a potential manifest file for app-thinning. Eventually, Xcode would create your distributable code-signed binaries. 
**[Slide 4]** 
Oh, and you'd still need to invite, enroll and get your app into the hands of each of your beta testers.  Didn't you used to… what was it called… *code*?
## Introducing Gym
That's our problem space in this section. I'm sure you won't be surprised to hear that `fastlane` has a solution waiting in the wings.
**[Slide 5]** 
We'll begin with `gym`, fastlane's action to automate the process of building your app for your selected distribution method. Let's take a closer look:
# Demo
## Command Line
`gym` follows `fastlane’s` standard conventions nicely, with its documentation at [../actions/gym][1] as expected. And once again, command line use is almost impossibly simple: 
```bash
fastlane gym
```
You'll find `gym` takes a bit longer than the other actions you've seen so far. This makes sense, because under the hood, it's leveraging `xcodebuild` and other command line tools as it builds your archive, checks its validity and builds your distributable binaries.
Here’s a quick Pro Tip: gym is tasked with working with a lot of pieces, and it’s possible for things to go wrong, causing lots of ugly red type to fly across your screen. If this ever happens to you, I’d recommend following the onscreen directions to review the related log files and fastlane debugging resources. I’ve also seen cases where either toggling automatic code signing off and back on, or manually creating and then *validating* an archive in Xcode have resolved odd issues with automatic code signing settings. 

## Gym options
Back in the command line, we can go beyond basic use to, say, specify a workspace, scheme *and* require a clean-and-build like this:
```bash
fastlane gym --workspace "Myworkspace.xcworkspace" --scheme "MyScheme" --clean
```
And we can choose our distribution method and where we want our distributable assets to be stored:
```bash
fastlane gym --export_method ad-hoc --output_directory "MyDirectory"
```
Finally, we can also specify manifest files and thinning options, as well as whether or not to include symbols and bitcode.

## Lane Use
Turning to use in lanes, the good news is that use here is very straightforward as well. You can invoke gym without as simply as this: 
```bash
lane :sandbox do
  gym
end
```
Or you can invoke clearly-named parameters to specify equivalents to any of the CLI options you just saw:
```bash
lane :sandbox do
  gym(
    scheme: "ChewChewTrain",
    output_directory: "build_AdHoc",
    build_method: "ad-hoc"
  )
end
```

## Gymfile
Last, you can place any project-wide build configurations in an optional  `Gymfile`. To do this, you simply run:
```bash
fastlane gym init
```
This scaffolds a new Ruby `Gymfile` configuration file in your project `fastlane` subdirectory. As with other `fastlane` config files, settings here effectively serve as project-wide defaults applying to `gym` in both the command line and lanes, unless you specifically override them.
I'll configure my project `Gymfile` quite simply, then specify my build method and location in my lanes:
```ruby
clean(true)
scheme "ChewChewTrain"
```
You’ll set up your own Gymfile in the next Challenge episode.
# Conclusion
`gym` is a that rare combination of a serious workhorse that's both easy to use and highly configurable. It lays the foundation for everything `fastlane` can do to help improve your test build and distribution workflow.
In the next section you'll head to the `gym` yourself, as you create and then customize a new build lane. See you there!

[1]:	https://docs.fastlane.tools/actions/gym