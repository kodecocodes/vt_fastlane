# Introduction
It's an exciting milestone in an app's lifecycle: You've taken your app from idea to functional, and it's time to get it into the hands of beta testers. Life is great! 
Except… As you think of the manual legwork that'll be needed to get your app provisioned and submitted and all your testers on-boarded, your heart sinks just a bit.
# Lecture
## Manual Build Steps
Here's a quick review of the conventional steps needed at this point:
**[Slide 1]** 
To start, you'd need to register all your test devices on the Apple Developer Portal. We get a pass on this one, since we've already addressed device registration with `deliver`. Onwards!
**[Slide 2]** 
You'd then create an archive, remembering to manually bump your build number. Then you stand by and cross your fingers while Xcode validates your app and all your distribution certificates and assets. 
**[Slide 3]** 
Then it's on to Xcode's Organizer, where you'd choose either to distribute your app with Test Flight or a third party service. You'd also choose a development team and account, if your app is Universal, and select any on-demand resources to be uploaded, including a potential manifest file for app-thinning. Eventually, Xcode would create your distributable code-signed binaries. 
**[Slide 4]** 
Oh, and you'd still need to invite, enroll and get your app into the hands of each of your beta testers.  Didn't you used to… what was it called… *code*?
## Introducing Gym
That's our problem space in this section. I'm sure you won't be surprised to hear that `fastlane` has a solution waiting in the wings.
**[Slide 5]** 
We'll begin with `gym`, fastlane's action to automate the process of building your app for your selected distribution method. Let's take a closer look:
# Demo
## Command Line
`gym` follows `fastlane’s` standard conventions nicely, with its documentation at [../actions/gym][1] as expected. And once again, command line use is almost impossibly simple: 
```bash
fastlane gym
```
You'll find `gym` takes a bit longer than the other actions you've seen so far. This makes sense, because under the hood, it's leveraging `xcodebuild` and other command line tools as it builds your archive, checks its validity and builds your distributable binaries.
## Viewing .ipa info
Once `gym` has done its thing, I’d like to take a look at the `.ipa` file it’s generated. But if I Get Info or do a Quick Look of an .ipa file up in Finder, I’ll get nada. 
<!-- Open in Finder, and show completely useless Quick Look info -->
Let's take a moment to fix this. `fastlane` recommends an open source QuickLook plugin called `ProvisionQL`.
\<!-- Show [https://github.com/ealeksandrov/ProvisionQL]() in browser --\\\\\>
I'll quickly install this with homebrew:
```bash
brew cask install provisionql
```
Great! Now, Quick Look shows me my `ipa's` type, provisioning, entitlements, certificates and more. Like any Quick Look plugin, this doesn't work in Get Info, but it does play nicely with Column View’s preview pane *and* Mojave's new Gallery view. 
Please take a moment now to pause the video and install `ProvisionQL` yourself. 
# Pause for Installation
# Continue Demo
Thanks for doing that… now back to our regularly scheduled programming :]
## Gym options
Back in the command line, we can go beyond basic use to, say, specify a workspace, scheme *and* require a clean-and-build like this:
```bash
fastlane gym --workspace "Myworkspace.xcworkspace" --scheme "MyScheme" --clean
```
And we can choose our distribution method and where we want our distributable assets to be stored:
```bash
fastlane gym --export_method ad-hoc --output_directory "MyDirectory"
```
Finally, we can also specify manifest files and thinning options, as well as whether or not to include symbols and bitcode.
## Lane Use
Turning to use in lanes, the good news is that use here is very straightforward as well. You can invoke gym without as simply as this: 
```bash
lane :mini_me do
  gym
end
```
Or you can invoke clearly-named parameters to specify equivalents to any of the CLI options you just saw:
```bash
lane :big_me do
  gym(
    scheme: "ChewChewTrain",
    output_directory: "build_AdHoc",
    build_method: "ad-hoc"
  )
end
```
## Gymfile
Last, you can place any project-wide build configurations in an optional  `Gymfile`. To do this, you simply run:
```bash
fastlane gym init
```
This scaffolds a new Ruby `Gymfile` configuration file in your project `fastlane` subdirectory. As with other `fastlane` config files, settings here effectively serve as project-wide defaults applying to `gym` in both the command line and lanes, unless you specifically override them.
I'll configure my project `Gymfile` quite simply, then specify my build method and location in my lanes:
```ruby
clean(true)
scheme "ChewChewTrain"
```
# Conclusion
`gym` is a that rare combination of a serious workhorse that's both easy to use and highly configurable. It lays the foundation for everything `fastlane` can do to help improve your test build and distribution workflow.
In the next section you'll head to the `gym` yourself, as you create and then customize a new build lane. See you there!

[1]:	https://docs.fastlane.tools/actions/gym
