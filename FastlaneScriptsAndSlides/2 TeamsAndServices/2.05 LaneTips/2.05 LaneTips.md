# Introduction
Your lanes are taking more shape. In this episode, I'll show you some helpful ways to add more power to them.
# Lecture
## Switching Lanes
So far, you've created a handful of lanes. Individually, each zips along nicely. But when we cruise down the highway, we want to be able to switch lanes. Let's see how to do that. 
Let's take an example: In the challenge you just completed, you first created a  `sync_all_development` lane, and then a separate `sync_device_info` lane. It makes sense to keep these actions in separate lanes. However, what I'd really like is to add the functionality of my `sync_device_info` directly into my `sync_all_development` lane.
**[Slide ]** Show the code
Fastlane makes this drop dead simple: You can call any lane directly from another, simply by using its name
```ruby
lane :my_lane do
  ...
  my_first_lane
  produce
  ...
end
```
**[Slide ]** Show the Cruising info inline below
Now when I run the sync\_all\_development lane, fastlane switching lanes automatically on my behalf, 
- Driving the lane ios `sync_all_development`ðŸš€
- Cruising over to lane `ios sync_app_info` ðŸš–
- Cruising back to lane `ios sync_all_development` ðŸš˜
**[Slide ]** Vault opened
Just as with well-formatted Swift code, we're now free to compose lanes as we'd compose functions and methods, and we can call them as needed. The only significant limitation is that if you can't call lanes inside a different platform grouping (in this course, all our lanes are within a single :iOS group, so this won't affect us here). Otherwise, you're free to repurpose lanes as you see fit
## Control Flow
**[Slide ]** 
You can add conditional logic much as you do in Swift. Ruby has a rich collection of flow control operators, much like Swift. I'll focus on simple if blocks. Except for the the lack of Swift's C-style bracketing, these are immediately intuitive.
```ruby
lane :my_lane do
  ...
  if some_variable == true
    # do some stuff
  else
    # do something else
  end
  ...
end
```
**[Slide ]** 
You can stop executing a lane before it reaches its end with the `next` keyword:
```ruby
lane :my_lane do
  ...
  if some_variable == true
	# do something
  else
    next # get the heck outta dodge
  end
  # more stuff
  ...
end
```
## Variables
You can define and use variables in your lanes. To declare a variable, simply assign it a variable. Using the variable, as well as variable scoping, shouldn't surprise you at all:
```ruby
lane :my_lane do
  my_var = "some value"
  ...
  some_action(
    parameter: my_var
  )
end
```
## Returning values
To return a value from a lane, simply put its value in the last line of the lane:
```ruby
lane :return_something do
  a_var = 4  
  ...
  a_var + 2
end
```
You can use this return value as you would any other value:
```ruby
  lane :use_returned_value do
    new_val = return_something * 10
    ...
  end
```
## Accepting parameters
You can configure any lane to accept input like this:
```ruby
lane :call_me do |options| 
   ...
end
```
You can call this lane with any ad hoc parameters you'd like:
```ruby
lane :checking_in do
  call_me(my_custom_param: true)
end
```
And then process the input list so:
```ruby
lane :call_me do |options| 
  if options[:my_custom_param]
    # do something
  end
end
```
## Interactions
Finally makes it easy to provide feedback:
```ruby
  lane :prompts_ahoy do
    UI.message "Neutral message (usually white)"
    UI.success "Successfully finished processing (usually green)"
    UI.error "Wahaha, what's going on here! (usually red)"
    UI.important "Make sure to use Windows (usually yellow)"
  end
```
You can also prompt users for input and branch depending on their response:
```ruby
  lane :secret do
    pw = UI.password("Your password please: ") # password inputs are hidden
    UI.message "Wow! Your password is really " + pw + "!!!"
  end
```
â€¦ and confirm / branch depending on what's entered:
```ruby
  lane :test do
    name = UI.input("What's your name? ")
    if UI.confirm("Are you '#{name}'?")
      UI.success "Good to know"
    else
      UI.error "Ruh ruh..."
      next # don't continue
    end
    ...
  end
```
# Conclusion
fastlane's lanes are flexible and powerful, ready to do anything you'll want them to do. Ultimately, you have the full power of Ruby *plus* everything fastlane has to offer at your disposal. And maybe nicest of all, the lane structure makes it easy for every non-Rubyists to tinker and learn, much like Swift playgrounds do.
In the next episode, I'll explain some best practices on using fastlane in the command line versus within lanes, along with several tips on getting the best out of both environments. See you there!