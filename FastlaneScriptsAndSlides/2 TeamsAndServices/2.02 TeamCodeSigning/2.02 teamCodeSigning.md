# Intro
In Section 1, you learned how fastlane can automatically manage your personal code signing credentials via the actions `cert` and `sigh`. These actions are robust, feature-complete, and highly performant. But excellent as these tools are, they're fundamentally tied to some problematic issues of how we've traditionally managed our iOS code signing assets. 
In this episode, you'll learn how fastlane proposes to make a Copernican Shift in how iOS teams manage their code signing credentials. It's an ambitious idea, and I think you'll really like it. So fasten your seatbelts, because our fastlane are about to get a lot… faster!
# Lecture
In fastlane's view, there's weak spot buried in the common scheme iOS development teams use to manage their credentials. Simply put, code signing assets are fundamentally tied to *individuals*. But modern iOS development typically takes place in *teams*. 
## The Trouble with Tribbles
**[Slide ]** 
Think of everything we've done so far with `cert` and `sigh`: Certificates and profiles are the property of individual developers. They're stored on an individual developer's machine, and core identities are tied once again to individual developers.
This works fine when you're a team of one. But what happens as your team grows? 
As each new team member is brought on board, they each have their own development machines, iOS devices, and most importantly, their individual signing requests, certificates, and keys. 
**[Slide ]** 
It's easy to see why the process developed this way historically. And this schema bears similarities to how Apple also views other cloud assets we all have, like our music, photos, bookmarks, and much more. It's natural to make things 1:1 with a developer.
The problem is that when we develop on teams, we naturally want to hoist our processes and thinking from an "I am an Island" worldview to a "there's no team without me" perspective. Oops, I mean, "there no I in team". 
Tools like git, Jira, Slack, and Trello all reflect this shift. Yes, we're all still individuals. But the center of gravity and how we store and access assets shifts to a centralized, team-centric view. At a certain point in any team's life, it's no longer OK to say "Go ask Bob… I think he's got those files". Teams need a consistency and centralization that individual-centric approaches make awkward.
**[Slide ]** Fastlane's the Problem image
Viewed from this perspective, the traditional individual-based approach to managing code signing assets isn't particularly well-suited to scaling up, and it's inherently brittle in a team context. 
If every developer on a team has their own code signing assets, provisioning profiles (which map code signing identities to apps and devices) will multiply. As teams change, developers come and go, and credentials expire, become corrupted or aren't correctly synced across all team devices, leaving team members without any code signing identities and causing significant managerial overhead. 
**[Slide ]** Tribbles!
individual profiles can propagate almost uncontrollably in this scheme, and managing them can feel surprisingly like trying to cope with an exploding population of Tribbles. Individual Tribbles are cute and cuddly. Exploding tribble populations are very bad. Just ask Scotty
Productivity suffers when members are blocked by missing required code signing identities. Maybe worst of all, every team developer needs full access to the Apple Developer Portal, raising the possibility that a tired developer's error might inadvertently cause an entire team real headaches.
## Fastlane's Revolutionary Solution
**[Slide ]** Code Signing Guide Website
Fastlane's solution to this traditional situation is to propose a Copernican Revolution. Fastlane takes this so seriously that they released a comprehensive Code Signing Guide, complete with its own website.
**[Slide ]** Revolving around the sun
Instead of making the team revolve around individual developers, why not put the team at the center of the cosmos. Why not make the locus of code signing the team itself, exactly as we do with our other team development tools? This way, a team could able to share a single set of code signing identities, certificates, and profiles in a centralized, version controlled place. Each team member would simply be able to pull this single set of code signing assets and provisioning profiles. 
**[Slide ]** git
How would we make this kind of shift? `fastlane's`  answer is to turn to the same tool that's solved this for team code and other assets: git. Git is centralized, secure, repos can (and must in this case) be private, and of course, it excels as a central point for distributable team assets.
Building on this, fastlane proposes a scheme in which a single set of *team* code signing credentials is obtained from Apple and stored in a private git repo. Not only does this shift credentials from the individual to the team; it also moves *storage* of these credentials from individual developer machines to git as well. From here, each team developer can pull this single set of assets to their own machines. 

Apple's requirements will still be fulfilled, but instead of an exploding of Tribbles, we'll just have a single cuddly Tribble. I shall call him Fluffy, and he shall be mine :)
**[Slide ]** 
Here's how this workflow would work in detail:
1. A team manager creates a fresh, private Git repo.
2. New private keys, profiles and certificates are created, encrypted  and stored in the private repo. 
3. Each team member imports the certificates and private keys to their Keychain, and the provisioning profiles are copied to their Libraries.
4. Each member configures Xcode to use these team assets.
## Really?
**[Slide ]** Devon and Fritz ruminating
Personally, when I first encountered this idea, I was both intrigued and more than a little… nervous. Do I really want to store my core signing assets — including my *private* code signing key — in the cloud? Traditionally, this lives on my own machine, and at least conceptually, that seems a lot safer than trusting any cloud provider… even git.
Fastlane does a nice job of clarifying the potential security risks or this approach, and also of comparing that to other risks we all face already:
**[Slide ]** 
1. If you follow fastlane's recommendations, your git repo storing your critical assets will be private. Further, unless you intentionally disable default functionality, all code-signing assets will automatically be OpenSSL-encrypted with a passphrase as they're being stored in the cloud. 
2. It's worth a reminder that we all rely on git every day to keep our critical code and virtually all other team assets safe, so it's likely not a significant leap to further trust them with our code signing assets. if we're willing to trust our intellectual property to git, why not the assets we use to code sign them?
2. But what if an attacker somehow stole a private key? To code sign your app, they'd also need to break into your separate project code repository. Further, to get an app code-signed by Apple they'd need to submit it for review, requiring they get your App Store Connect credentials, and they aren't in this git repo. Similar safeties hold for attempts to install a signed application onto ad hoc iOS devices, where the attacker would again need additional assets not in this repo.  
	  
	Enterprise profiles do present more risk, and there *is* a possibility an attacker could distribute a signed application with the organization's name. Even here, however, the enterprise certificate could simply revoked, instantly breaking any illicitly-modified apps.
3. As a final precaution, fastlane advises using the best practice of having every team member enable 2 factor git authentication. This provides a final layer of security, and is, of course, equally advisable for all your project git repos. 
## The Verdict
**[Slide ]** 
So what's the verdict?
There's no absolute answer, of course. There's absolutely finite risk with this approach. For that matter, there's non-trivial risk with the *standard* individual-based approach we all use by default, as there is with using an online repository for storing our project code and much more. Here as elsewhere, each team must weigh benefits and risks, and find their own balance between security, convenience and efficiency. 
My own sense is quite simply that fastlane has effectively addressed my security concerns, and that potential gains in team efficiency are highly compelling. 
But that's my own take. It's important to be clear that while fastlane clearly believes this is a far better approach in *most* cases, it doesn't push you. You can build complete fastlane workflows using the same tools — `cert` and `sigh` — that you saw in the previous Section, or you can use the team-based code-signing action — `match` — that you'll meet in the next section. The choice is yours, and that's a great thing.
# Conclusion
In the next episode, you'll meet the fastlane action that powers fastlane's new team-based code signing approach. See you there!